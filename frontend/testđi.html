<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ch·∫•m c√¥ng b·∫±ng khu√¥n m·∫∑t</title>

  <!-- OpenCV.js & utils.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
  <script src="https://docs.opencv.org/4.x/utils.js" type="text/javascript"></script>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    #canvas {
      border: 2px solid #ccc;
      margin-top: 10px;
      max-width: 100%;
    }
    #countdown {
      font-size: 2rem;
      font-weight: bold;
      color: red;
      margin-top: 10px;
    }
  </style>
</head>

<body class="container py-5 text-center">

  <h2 class="mb-4">üì∑ Ch·∫•m c√¥ng b·∫±ng khu√¥n m·∫∑t</h2>

  <div class="d-flex flex-column align-items-center">
    <!-- ·∫®n video: ch·ªâ d√πng ƒë·ªÉ stream n·ªôi b·ªô -->
    <video id="video" autoplay playsinline ></video>
    
    <!-- Canvas hi·ªÉn th·ªã video + khung khu√¥n m·∫∑t -->
    <canvas id="canvas"></canvas>

    <div id="countdown"></div>

    <p class="text-muted mt-2">üí° Gi·ªØ khu√¥n m·∫∑t r√µ n√©t, √°nh s√°ng ƒë·ªß v√† nh√¨n th·∫≥ng v√†o camera</p>

    <div class="btn-group mt-3 gap-2">
      <button class="btn btn-success" onclick="startCountdown()">üì∏ Ch·∫•m c√¥ng</button>
    </div>
  </div>

  <div id="response" class="mt-4 text-center"></div>

  <script type="text/javascript">
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const countdownEl = document.getElementById("countdown");
    const responseDiv = document.getElementById("response");

    let faceClassifier;
    let streaming = false;
    const utils = new Utils('errorMessage');

    // M·ªü camera
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => {
        video.srcObject = stream;
        video.play();
      })
      .catch(err => alert("‚ùå Kh√¥ng th·ªÉ truy c·∫≠p camera"));

    // OpenCV s·∫µn s√†ng
    window.Module = {
      onRuntimeInitialized() {
        console.log("‚úÖ OpenCV.js ƒë√£ s·∫µn s√†ng!");

        const cascadeFile = 'haarcascade_frontalface_default.xml';
        faceClassifier = new cv.CascadeClassifier();

        utils.createFileFromUrl(cascadeFile, cascadeFile, () => {
          faceClassifier.load(cascadeFile);
          console.log("‚úÖ ƒê√£ load cascade th√†nh c√¥ng");
          streaming = true;
          requestAnimationFrame(processVideo);
        });
      }
    };

    function processVideo() {
      if (!streaming) return;

      const ctx = canvas.getContext("2d");
      const width = video.videoWidth;
      const height = video.videoHeight;

      if (width === 0 || height === 0) {
        requestAnimationFrame(processVideo);
        return;
      }

      canvas.width = width;
      canvas.height = height;

      // V·∫Ω frame video l√™n canvas
      ctx.drawImage(video, 0, 0, width, height);

      // OpenCV x·ª≠ l√Ω ·∫£nh
      let src = cv.imread(canvas);
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

      let faces = new cv.RectVector();
      faceClassifier.detectMultiScale(gray, faces, 1.1, 3, 0);

      if (faces.size() === 0) {
        // Kh√¥ng ph√°t hi·ªán khu√¥n m·∫∑t
        ctx.font = "24px Arial";
        ctx.fillStyle = "red";
        ctx.textAlign = "center";
        ctx.fillText("‚ùå Kh√¥ng ph√°t hi·ªán khu√¥n m·∫∑t", width / 2, 40);
      } else {
        // V·∫Ω khung khu√¥n m·∫∑t
        for (let i = 0; i < faces.size(); i++) {
          let face = faces.get(i);
          ctx.strokeStyle = "#00ff00";
          ctx.lineWidth = 2;
          ctx.strokeRect(face.x, face.y, face.width, face.height);
        }
      }

      // D·ªçn b·ªô nh·ªõ
      src.delete(); gray.delete(); faces.delete();

      requestAnimationFrame(processVideo);
    }

    function startCountdown() {
      responseDiv.innerHTML = '';
      let seconds = 3;
      countdownEl.textContent = seconds;

      const interval = setInterval(() => {
        seconds--;
        countdownEl.textContent = seconds > 0 ? seconds : '';
        if (seconds <= 0) {
          clearInterval(interval);
          takePicture();
        }
      }, 1000);
    }

    function takePicture() {
      const dataURL = canvas.toDataURL("image/jpeg");
      submitImage(dataURL);
    }

    async function submitImage(base64Image) {
      try {
        const response = await fetch("http://127.0.0.1:5000/api/face-checkin", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ image_base64: base64Image })
        });

        const result = await response.json();
        responseDiv.innerHTML = `<div class="alert alert-${response.ok ? 'success' : 'danger'}">
          ${result.message || (response.ok ? 'Ch·∫•m c√¥ng th√†nh c√¥ng!' : 'Ch·∫•m c√¥ng th·∫•t b·∫°i')}
        </div>`;
      } catch (error) {
        responseDiv.innerHTML = `<div class="alert alert-danger">‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn server.</div>`;
      } finally {
        countdownEl.textContent = '';
      }
    }
  </script>
</body>
</html>
